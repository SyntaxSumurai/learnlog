## Custom Classes
In Java collections can store custom objects allowing you to define your own classes & use them within collctions such as list, set & map

```java
import java.util.*;

class Person {
    String name;
    int age;

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return name + " (" + age + ")";
    }
}

public class Main {
    public static void main(String[] args) {
        List<Person> people = new ArrayList<>();
        people.add(new Person("Alice", 30));
        people.add(new Person("Bob", 25));

        System.out.println(people);
    }
}
```

Now in above code we have used the Person class to define our custom type and then we have store our new type of data in an ArrayList in a very simple manner.

Means the people arraylist will have data like this 
```txt title="Output" 
[Alice (30), Bob (25)] 
```

What actually happens is that when new Person is called with some values `("Alice",30)` then a new object is created and that calls the constructor of People class and it then stores the data for that object into `name` and `age` variables. And for each objects it does the same thing.

:::note Question
Okay I have understood the logic but why is the output coming like this then?
:::

Actually the reason for this kind of output is we have `@Override` the actual toString so our method will be used for any string conversion and printing using toString method.

## List
>A list is an ordered collection that allows duplicate elements it provides positional access & is commonly used in scenarios where order matters.

### i. ArrayList
>Arraylist is a reusable array of the list interface. It offers random access very fast but slower insertion and deletion as elements needed to be shifted.

```java
List<String> arr = new String<>();
arr.add("Hello");
arr.add("World");
System.out.println(arr); // [Hello, World]
```
:::info Articles reference
Please check these articles for more information:
- [Java ArrayList GFG](https://www.geeksforgeeks.org/java/arraylist-in-java/)
- [Java ArrayList W3 schools](https://www.w3schools.com/java/java_ref_arraylist.asp)
:::

### ii. LinkedList
>Linkedlist is a doubly linkedlist implementation to the list interface. It provides fast insertion & deletion but slower random access compared to arraylist.

```java 
LinkedList<Integer> ls = new LinkedList<>();
ls.add(1);
ls.add(2);
ls.add(3);
System.out.println(ls); // [1, 2, 3]
```
:::info Article reference
- [LinkedList GFG](https://www.geeksforgeeks.org/java/linked-list-in-java/)
- [LinkedList W3 schools](https://www.w3schools.com/java/java_linkedlist.asp)
:::

### iii. Stack
>Stack is a subclass of vector that implements a Last In First Out (LIFO) principle.

<p style={{textAlign: 'center' }}>
  <img
    src="https://cdn.programiz.com/sites/tutorial2program/files/stack-operations.png"
    alt="Stack Data structure visualization"
    style={{ backgroundColor: 'white' }}
  />
  <br />
  <em>
    <a href="https://www.programiz.com/dsa/stack" target="_blank" rel="noopener noreferrer">
      Image Source: Programiz - Stack Data Structure
    </a>
  </em>
</p>


```java title="Code Example"
Stack<Integer> stack = new Stack<>();
import java.util.*;

class Main {
    public static void main(String[] args) {
        Stack<Integer> stack = new Stack<>();
        
        stack.push(10);
        stack.push(50);
        stack.push(20);
        stack.push(90);
        
        System.out.println(stack.peek()); // returns lastly inserted element
        
        System.out.println(stack.empty()); // returns whether the stack is empty or not
        
        System.out.println(stack);
    }
}
```

```output title="Output"
90
false
[10, 50, 20, 90]
```

:::info Article Reference
- [Stack GFG](https://www.geeksforgeeks.org/java/stack-class-in-java/)
:::

### iv. Vector
>Vector in java is similar to ArrayList but it is synchronized meaning it is thread safe for multithreading environment.

<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/20200817110421/vector.png" alt="Stack Data structure visualization" />
  <br />
  <em><a href="https://www.geeksforgeeks.org/java/java-util-vector-class-java/" target="_blank" rel="noopener noreferrer" >Image Source: Geeks for Geeks - Vector Data Structure</a></em>
</p>

```java title="Syntax"
Vector<Integer> vector = new Vector<>();
```

Now we can define vector in many ways.

1. Vector(): Vector by default is initialised with capacity of 10.
```java title="Default Vector"
Vector<E> vector = new Vector<E>();
```

2. Vector(int size): In vector we can also specify the capacity
```java title="Vector with initial capacity"
Vector<E> vector = new Vector<E>(int size);
```

3. Vector(int size,int incr): In vector we can specify size and also the increment like if that size exceeds then vector automatically increases the size/capacity specified as the increment value.
```java title="Vector with capacity and increment value"
Vector<E> vector = new Vector<E>(int size, int incr);
```

4. Vector(Collection c): Creates a vector that contains the element of collection c.
```java title="Vector with Elements of a Collection"
Vector<E> v = new Vector<E>(Collection c);
```

```java title="Example"
import java.util.*;

class Main {
    public static void main(String[] args) {
        Vector<Integer> vector = new Vector<>(3,2);
        
        vector.addElement(1);
        vector.addElement(2);
        vector.addElement(3);
        
        vector.insertElementAt(0,1);
        vector.removeElementAt(2);
        
        System.out.println(vector);
    }
}
```

```Output title="Output"
[1, 0, 3]
```

Also as we can see that vector implements the List hence we can use the methods and all that of List Interface. You can checkout the usage of the methods used in from this link [GFG Vector](https://www.geeksforgeeks.org/java/java-util-vector-class-java/)

## Set
> A set is a collection that doesn't allow duplicate elements. It's useful when you need to store unique elements.

### i. HashSet
Hashset is a collection that stores unique elements and returns the elements in a random order.

```java title="Syntax"
HashSet<String> cars = new HashSet<>();
cars.add("Volvo");
cars.add("BMW");
cars.add("Ford");
cars.add("BMW"); //Duplicate
cars.add("Mazda");

//contains method: checks whether the set contains that element or not
System.out.println(cars.contains("Mazda"));

//remove method: Removes the value from set if exist
System.out.println(cars.remove("Volvo"));
System.out.println(cars);

//size method to check the current size of the set
System.out.println(cars.size());

//clear method used to remove all the elements
System.out.println(cars.clear());

System.out.println(cars);
```


```Output title="Output"
true
true
[Mazda, Ford, BMW]
3
[]
```
:::info Article Reference
- [W3 Schools](https://www.w3schools.com/java/java_hashset.asp)
:::

### ii. TreeSet
- TreeSet is same as HashSet just this gives us element in a sorted order

```java title="Syntax"
TreeSet<Integer> ts = new TreeSet<>();
```

### Complexity analysis between HashSet and TreeSet
| Data Structure | Complexity|
|----------------|-----------|
| HashSet        | O(1)      |
| TreeSet        | O(LogN)   |


## Queue
> A Queue is a collection that follows First In First Out principle (FIFO).

<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/20200903183026/Queue-Deque-PriorityQueue-In-Java.png" alt="Stack Data structure visualization" height="400px" width="400px" />
  <br />
  <em><a href="https://www.geeksforgeeks.org/java/deque-interface-java-example/" target="_blank" rel="noopener noreferrer" >Image Source: Geeks for Geeks - Dequeue Interface</a></em>
</p>

i. ArrayDeque
> ArrayDeque is a subtype of a Queue Interface. And Deque simply means Double Ended Queue means we can added and remove from anyside. Means we can achive both the principles FIFO as well as LIFO.

```java title="Syntax"
ArrayDeque<Type> deque = new ArrayDeque<>();
```


```java title="Dequeue Example"
import java.util.ArrayDeque;
import java.util.Deque;

public class Geeks {
    
    public static void main(String[] args) {
        
        Deque<Integer> d = new ArrayDeque<>();
        d.addFirst(1);
        d.addLast(2);
        int f = d.removeFirst();
        int l = d.removeLast();
        System.out.println("First: " + f + ", Last: " + l);
    }
}
```

```Output title="Output"
First: 1, Last: 2
```